function generateFieldSql(
  field: FieldProperties,
  forCreateTable: boolean = false,
): string {
  let sql = `${field.name} ${field.type.toUpperCase()}`;
  if (field.primarykey && forCreateTable) sql += " PRIMARY KEY";
  if (field.autoincreasement && forCreateTable) sql += " AUTOINCREMENT";
  if (field.required && forCreateTable) sql += " NOT NULL";
  if (field.unique && forCreateTable) sql += " UNIQUE";
  if (field.default !== undefined && forCreateTable) {
    sql += ` DEFAULT ${typeof field.default === "string" ? `'${field.default}'` : field.default}`;
  }
  return sql;
}

function generateCreateTableSql(collection: CollectionSchema): string {
  const fieldsSql = collection.fields
    .map((f) => generateFieldSql(f, true))
    .join(", ");
  let sql = `CREATE TABLE ${collection.name} (${fieldsSql})`;
  if (collection.references) {
    const constraints = collection.references
      .map(
        (ref) =>
          `FOREIGN KEY (${ref.key}) REFERENCES ${ref.targetTable}(${ref.targetKey})`,
      )
      .join(", ");
    sql = `CREATE TABLE ${collection.name} (${fieldsSql}, ${constraints})`;
  }
  return sql;
}

async function generateMigration(
  currentSchema: CollectionSchema[],
  newSchema: CollectionSchema[],
) {
  const timestamp = Date.now();
  const migrationName = `${timestamp}_auto_migration.ts`;
  const migrationPath = path.join("handly/migration", migrationName);
  let upQueries: string[] = [];
  let downQueries: string[] = [];

  for (const newColl of newSchema) {
    const currentColl = currentSchema.find((c) => c.name === newColl.name);
    if (!currentColl) {
      upQueries.push(generateCreateTableSql(newColl));
      downQueries.push(`DROP TABLE ${newColl.name}`);
    } else {
      const differences = diff(currentColl.fields, newColl.fields);
      if (differences) {
        for (const d of differences) {
          if (d.kind === "D") {
            const field = (d as any).lhs;
            upQueries.push(
              `ALTER TABLE ${newColl.name} DROP COLUMN ${field.name}`,
            );
            downQueries.push(
              `ALTER TABLE ${newColl.name} ADD COLUMN ${generateFieldSql(field)}`,
            );
          } else if (d.kind === "N" && d.path && d.path.length === 1) {
            const field = (d as any).rhs;
            upQueries.push(
              `ALTER TABLE ${newColl.name} ADD COLUMN ${generateFieldSql(field)}`,
            );
            downQueries.push(
              `ALTER TABLE ${newColl.name} DROP COLUMN ${field.name}`,
            );
          } else if (d.kind === "N" || d.kind === "E") {
            const tempTable = `${newColl.name}_temp`;
            upQueries.push(
              `ALTER TABLE ${newColl.name} RENAME TO ${tempTable}`,
              generateCreateTableSql(newColl),
              `INSERT INTO ${newColl.name} (${newColl.fields.map((f) => f.name).join(", ")}) ` +
                `SELECT ${newColl.fields.map((f) => f.name).join(", ")} FROM ${tempTable}`,
              `DROP TABLE ${tempTable}`,
            );
            downQueries.push(
              `ALTER TABLE ${newColl.name} RENAME TO ${tempTable}`,
              generateCreateTableSql(currentColl),
              `INSERT INTO ${currentColl.name} (${currentColl.fields.map((f) => f.name).join(", ")}) ` +
                `SELECT ${currentColl.fields.map((f) => f.name).join(", ")} FROM ${tempTable}`,
              `DROP TABLE ${tempTable}`,
            );
            break;
          }
        }
      }
      const refDiff = diff(
        currentColl.references || [],
        newColl.references || [],
      );
      if (refDiff) {
        for (const d of refDiff) {
          if (d.kind === "N") {
            const ref = (d as any).rhs;
            upQueries.push(
              `ALTER TABLE ${newColl.name} ADD FOREIGN KEY (${ref.key}) REFERENCES ${ref.targetTable}(${ref.targetKey})`,
            );
            downQueries.push(
              `ALTER TABLE ${newColl.name} DROP FOREIGN KEY (${ref.key})`,
            );
          }
        }
      }
    }
  }

  const migrationContent = `
export async function up(db: any) {
  ${upQueries.map((q) => `await db.exec(\`${q}\`);`).join("\n  ")}
}

export async function down(db: any) {
  ${downQueries.map((q) => `await db.exec(\`${q}\`);`).join("\n  ")}
}
  `;

  await mkdir("handly/migrations", { recursive: true });
  await writeFile(migrationPath, migrationContent);
  return { upQueries, downQueries, migrationName };
}
